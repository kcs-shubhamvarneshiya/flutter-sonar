// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'login_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$LoginState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(bool value) loaded,
    required TResult Function(String error) error,
    required TResult Function(bool value) internetAvailable,
    required TResult Function(int progress) progressUpdate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(bool value)? loaded,
    TResult? Function(String error)? error,
    TResult? Function(bool value)? internetAvailable,
    TResult? Function(int progress)? progressUpdate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(bool value)? loaded,
    TResult Function(String error)? error,
    TResult Function(bool value)? internetAvailable,
    TResult Function(int progress)? progressUpdate,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoginStateLoadingState value) loading,
    required TResult Function(_LoginStateLoadedState value) loaded,
    required TResult Function(_LoginStateErrorState value) error,
    required TResult Function(_LoginConnectionState value) internetAvailable,
    required TResult Function(_LoginProgress value) progressUpdate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoginStateLoadingState value)? loading,
    TResult? Function(_LoginStateLoadedState value)? loaded,
    TResult? Function(_LoginStateErrorState value)? error,
    TResult? Function(_LoginConnectionState value)? internetAvailable,
    TResult? Function(_LoginProgress value)? progressUpdate,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoginStateLoadingState value)? loading,
    TResult Function(_LoginStateLoadedState value)? loaded,
    TResult Function(_LoginStateErrorState value)? error,
    TResult Function(_LoginConnectionState value)? internetAvailable,
    TResult Function(_LoginProgress value)? progressUpdate,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoginStateCopyWith<$Res> {
  factory $LoginStateCopyWith(
          LoginState value, $Res Function(LoginState) then) =
      _$LoginStateCopyWithImpl<$Res, LoginState>;
}

/// @nodoc
class _$LoginStateCopyWithImpl<$Res, $Val extends LoginState>
    implements $LoginStateCopyWith<$Res> {
  _$LoginStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LoginStateLoadingStateImplCopyWith<$Res> {
  factory _$$LoginStateLoadingStateImplCopyWith(
          _$LoginStateLoadingStateImpl value,
          $Res Function(_$LoginStateLoadingStateImpl) then) =
      __$$LoginStateLoadingStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoginStateLoadingStateImplCopyWithImpl<$Res>
    extends _$LoginStateCopyWithImpl<$Res, _$LoginStateLoadingStateImpl>
    implements _$$LoginStateLoadingStateImplCopyWith<$Res> {
  __$$LoginStateLoadingStateImplCopyWithImpl(
      _$LoginStateLoadingStateImpl _value,
      $Res Function(_$LoginStateLoadingStateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoginStateLoadingStateImpl implements _LoginStateLoadingState {
  const _$LoginStateLoadingStateImpl();

  @override
  String toString() {
    return 'LoginState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoginStateLoadingStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(bool value) loaded,
    required TResult Function(String error) error,
    required TResult Function(bool value) internetAvailable,
    required TResult Function(int progress) progressUpdate,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(bool value)? loaded,
    TResult? Function(String error)? error,
    TResult? Function(bool value)? internetAvailable,
    TResult? Function(int progress)? progressUpdate,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(bool value)? loaded,
    TResult Function(String error)? error,
    TResult Function(bool value)? internetAvailable,
    TResult Function(int progress)? progressUpdate,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoginStateLoadingState value) loading,
    required TResult Function(_LoginStateLoadedState value) loaded,
    required TResult Function(_LoginStateErrorState value) error,
    required TResult Function(_LoginConnectionState value) internetAvailable,
    required TResult Function(_LoginProgress value) progressUpdate,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoginStateLoadingState value)? loading,
    TResult? Function(_LoginStateLoadedState value)? loaded,
    TResult? Function(_LoginStateErrorState value)? error,
    TResult? Function(_LoginConnectionState value)? internetAvailable,
    TResult? Function(_LoginProgress value)? progressUpdate,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoginStateLoadingState value)? loading,
    TResult Function(_LoginStateLoadedState value)? loaded,
    TResult Function(_LoginStateErrorState value)? error,
    TResult Function(_LoginConnectionState value)? internetAvailable,
    TResult Function(_LoginProgress value)? progressUpdate,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _LoginStateLoadingState implements LoginState {
  const factory _LoginStateLoadingState() = _$LoginStateLoadingStateImpl;
}

/// @nodoc
abstract class _$$LoginStateLoadedStateImplCopyWith<$Res> {
  factory _$$LoginStateLoadedStateImplCopyWith(
          _$LoginStateLoadedStateImpl value,
          $Res Function(_$LoginStateLoadedStateImpl) then) =
      __$$LoginStateLoadedStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool value});
}

/// @nodoc
class __$$LoginStateLoadedStateImplCopyWithImpl<$Res>
    extends _$LoginStateCopyWithImpl<$Res, _$LoginStateLoadedStateImpl>
    implements _$$LoginStateLoadedStateImplCopyWith<$Res> {
  __$$LoginStateLoadedStateImplCopyWithImpl(_$LoginStateLoadedStateImpl _value,
      $Res Function(_$LoginStateLoadedStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$LoginStateLoadedStateImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$LoginStateLoadedStateImpl implements _LoginStateLoadedState {
  const _$LoginStateLoadedStateImpl(this.value);

  @override
  final bool value;

  @override
  String toString() {
    return 'LoginState.loaded(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoginStateLoadedStateImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoginStateLoadedStateImplCopyWith<_$LoginStateLoadedStateImpl>
      get copyWith => __$$LoginStateLoadedStateImplCopyWithImpl<
          _$LoginStateLoadedStateImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(bool value) loaded,
    required TResult Function(String error) error,
    required TResult Function(bool value) internetAvailable,
    required TResult Function(int progress) progressUpdate,
  }) {
    return loaded(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(bool value)? loaded,
    TResult? Function(String error)? error,
    TResult? Function(bool value)? internetAvailable,
    TResult? Function(int progress)? progressUpdate,
  }) {
    return loaded?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(bool value)? loaded,
    TResult Function(String error)? error,
    TResult Function(bool value)? internetAvailable,
    TResult Function(int progress)? progressUpdate,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoginStateLoadingState value) loading,
    required TResult Function(_LoginStateLoadedState value) loaded,
    required TResult Function(_LoginStateErrorState value) error,
    required TResult Function(_LoginConnectionState value) internetAvailable,
    required TResult Function(_LoginProgress value) progressUpdate,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoginStateLoadingState value)? loading,
    TResult? Function(_LoginStateLoadedState value)? loaded,
    TResult? Function(_LoginStateErrorState value)? error,
    TResult? Function(_LoginConnectionState value)? internetAvailable,
    TResult? Function(_LoginProgress value)? progressUpdate,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoginStateLoadingState value)? loading,
    TResult Function(_LoginStateLoadedState value)? loaded,
    TResult Function(_LoginStateErrorState value)? error,
    TResult Function(_LoginConnectionState value)? internetAvailable,
    TResult Function(_LoginProgress value)? progressUpdate,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _LoginStateLoadedState implements LoginState {
  const factory _LoginStateLoadedState(final bool value) =
      _$LoginStateLoadedStateImpl;

  bool get value;
  @JsonKey(ignore: true)
  _$$LoginStateLoadedStateImplCopyWith<_$LoginStateLoadedStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoginStateErrorStateImplCopyWith<$Res> {
  factory _$$LoginStateErrorStateImplCopyWith(_$LoginStateErrorStateImpl value,
          $Res Function(_$LoginStateErrorStateImpl) then) =
      __$$LoginStateErrorStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$LoginStateErrorStateImplCopyWithImpl<$Res>
    extends _$LoginStateCopyWithImpl<$Res, _$LoginStateErrorStateImpl>
    implements _$$LoginStateErrorStateImplCopyWith<$Res> {
  __$$LoginStateErrorStateImplCopyWithImpl(_$LoginStateErrorStateImpl _value,
      $Res Function(_$LoginStateErrorStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$LoginStateErrorStateImpl(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$LoginStateErrorStateImpl implements _LoginStateErrorState {
  const _$LoginStateErrorStateImpl(this.error);

  @override
  final String error;

  @override
  String toString() {
    return 'LoginState.error(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoginStateErrorStateImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoginStateErrorStateImplCopyWith<_$LoginStateErrorStateImpl>
      get copyWith =>
          __$$LoginStateErrorStateImplCopyWithImpl<_$LoginStateErrorStateImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(bool value) loaded,
    required TResult Function(String error) error,
    required TResult Function(bool value) internetAvailable,
    required TResult Function(int progress) progressUpdate,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(bool value)? loaded,
    TResult? Function(String error)? error,
    TResult? Function(bool value)? internetAvailable,
    TResult? Function(int progress)? progressUpdate,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(bool value)? loaded,
    TResult Function(String error)? error,
    TResult Function(bool value)? internetAvailable,
    TResult Function(int progress)? progressUpdate,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoginStateLoadingState value) loading,
    required TResult Function(_LoginStateLoadedState value) loaded,
    required TResult Function(_LoginStateErrorState value) error,
    required TResult Function(_LoginConnectionState value) internetAvailable,
    required TResult Function(_LoginProgress value) progressUpdate,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoginStateLoadingState value)? loading,
    TResult? Function(_LoginStateLoadedState value)? loaded,
    TResult? Function(_LoginStateErrorState value)? error,
    TResult? Function(_LoginConnectionState value)? internetAvailable,
    TResult? Function(_LoginProgress value)? progressUpdate,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoginStateLoadingState value)? loading,
    TResult Function(_LoginStateLoadedState value)? loaded,
    TResult Function(_LoginStateErrorState value)? error,
    TResult Function(_LoginConnectionState value)? internetAvailable,
    TResult Function(_LoginProgress value)? progressUpdate,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _LoginStateErrorState implements LoginState {
  const factory _LoginStateErrorState(final String error) =
      _$LoginStateErrorStateImpl;

  String get error;
  @JsonKey(ignore: true)
  _$$LoginStateErrorStateImplCopyWith<_$LoginStateErrorStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoginConnectionStateImplCopyWith<$Res> {
  factory _$$LoginConnectionStateImplCopyWith(_$LoginConnectionStateImpl value,
          $Res Function(_$LoginConnectionStateImpl) then) =
      __$$LoginConnectionStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool value});
}

/// @nodoc
class __$$LoginConnectionStateImplCopyWithImpl<$Res>
    extends _$LoginStateCopyWithImpl<$Res, _$LoginConnectionStateImpl>
    implements _$$LoginConnectionStateImplCopyWith<$Res> {
  __$$LoginConnectionStateImplCopyWithImpl(_$LoginConnectionStateImpl _value,
      $Res Function(_$LoginConnectionStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$LoginConnectionStateImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$LoginConnectionStateImpl implements _LoginConnectionState {
  const _$LoginConnectionStateImpl(this.value);

  @override
  final bool value;

  @override
  String toString() {
    return 'LoginState.internetAvailable(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoginConnectionStateImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoginConnectionStateImplCopyWith<_$LoginConnectionStateImpl>
      get copyWith =>
          __$$LoginConnectionStateImplCopyWithImpl<_$LoginConnectionStateImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(bool value) loaded,
    required TResult Function(String error) error,
    required TResult Function(bool value) internetAvailable,
    required TResult Function(int progress) progressUpdate,
  }) {
    return internetAvailable(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(bool value)? loaded,
    TResult? Function(String error)? error,
    TResult? Function(bool value)? internetAvailable,
    TResult? Function(int progress)? progressUpdate,
  }) {
    return internetAvailable?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(bool value)? loaded,
    TResult Function(String error)? error,
    TResult Function(bool value)? internetAvailable,
    TResult Function(int progress)? progressUpdate,
    required TResult orElse(),
  }) {
    if (internetAvailable != null) {
      return internetAvailable(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoginStateLoadingState value) loading,
    required TResult Function(_LoginStateLoadedState value) loaded,
    required TResult Function(_LoginStateErrorState value) error,
    required TResult Function(_LoginConnectionState value) internetAvailable,
    required TResult Function(_LoginProgress value) progressUpdate,
  }) {
    return internetAvailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoginStateLoadingState value)? loading,
    TResult? Function(_LoginStateLoadedState value)? loaded,
    TResult? Function(_LoginStateErrorState value)? error,
    TResult? Function(_LoginConnectionState value)? internetAvailable,
    TResult? Function(_LoginProgress value)? progressUpdate,
  }) {
    return internetAvailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoginStateLoadingState value)? loading,
    TResult Function(_LoginStateLoadedState value)? loaded,
    TResult Function(_LoginStateErrorState value)? error,
    TResult Function(_LoginConnectionState value)? internetAvailable,
    TResult Function(_LoginProgress value)? progressUpdate,
    required TResult orElse(),
  }) {
    if (internetAvailable != null) {
      return internetAvailable(this);
    }
    return orElse();
  }
}

abstract class _LoginConnectionState implements LoginState {
  const factory _LoginConnectionState(final bool value) =
      _$LoginConnectionStateImpl;

  bool get value;
  @JsonKey(ignore: true)
  _$$LoginConnectionStateImplCopyWith<_$LoginConnectionStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoginProgressImplCopyWith<$Res> {
  factory _$$LoginProgressImplCopyWith(
          _$LoginProgressImpl value, $Res Function(_$LoginProgressImpl) then) =
      __$$LoginProgressImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int progress});
}

/// @nodoc
class __$$LoginProgressImplCopyWithImpl<$Res>
    extends _$LoginStateCopyWithImpl<$Res, _$LoginProgressImpl>
    implements _$$LoginProgressImplCopyWith<$Res> {
  __$$LoginProgressImplCopyWithImpl(
      _$LoginProgressImpl _value, $Res Function(_$LoginProgressImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? progress = null,
  }) {
    return _then(_$LoginProgressImpl(
      null == progress
          ? _value.progress
          : progress // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LoginProgressImpl implements _LoginProgress {
  const _$LoginProgressImpl(this.progress);

  @override
  final int progress;

  @override
  String toString() {
    return 'LoginState.progressUpdate(progress: $progress)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoginProgressImpl &&
            (identical(other.progress, progress) ||
                other.progress == progress));
  }

  @override
  int get hashCode => Object.hash(runtimeType, progress);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoginProgressImplCopyWith<_$LoginProgressImpl> get copyWith =>
      __$$LoginProgressImplCopyWithImpl<_$LoginProgressImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(bool value) loaded,
    required TResult Function(String error) error,
    required TResult Function(bool value) internetAvailable,
    required TResult Function(int progress) progressUpdate,
  }) {
    return progressUpdate(progress);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(bool value)? loaded,
    TResult? Function(String error)? error,
    TResult? Function(bool value)? internetAvailable,
    TResult? Function(int progress)? progressUpdate,
  }) {
    return progressUpdate?.call(progress);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(bool value)? loaded,
    TResult Function(String error)? error,
    TResult Function(bool value)? internetAvailable,
    TResult Function(int progress)? progressUpdate,
    required TResult orElse(),
  }) {
    if (progressUpdate != null) {
      return progressUpdate(progress);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoginStateLoadingState value) loading,
    required TResult Function(_LoginStateLoadedState value) loaded,
    required TResult Function(_LoginStateErrorState value) error,
    required TResult Function(_LoginConnectionState value) internetAvailable,
    required TResult Function(_LoginProgress value) progressUpdate,
  }) {
    return progressUpdate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoginStateLoadingState value)? loading,
    TResult? Function(_LoginStateLoadedState value)? loaded,
    TResult? Function(_LoginStateErrorState value)? error,
    TResult? Function(_LoginConnectionState value)? internetAvailable,
    TResult? Function(_LoginProgress value)? progressUpdate,
  }) {
    return progressUpdate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoginStateLoadingState value)? loading,
    TResult Function(_LoginStateLoadedState value)? loaded,
    TResult Function(_LoginStateErrorState value)? error,
    TResult Function(_LoginConnectionState value)? internetAvailable,
    TResult Function(_LoginProgress value)? progressUpdate,
    required TResult orElse(),
  }) {
    if (progressUpdate != null) {
      return progressUpdate(this);
    }
    return orElse();
  }
}

abstract class _LoginProgress implements LoginState {
  const factory _LoginProgress(final int progress) = _$LoginProgressImpl;

  int get progress;
  @JsonKey(ignore: true)
  _$$LoginProgressImplCopyWith<_$LoginProgressImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
